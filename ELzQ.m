function [E, Lz, Q] = ELzQ(a, e, p, iota_deg)%% [E, Lz, Q] = ELzQ(a, e, p, iota_deg)%% Given the parameters%%         a = dimensionless black hole spin parameter ( 0 <= a < 1)%         e = eccentricity %         p = dimensionless semilatus-rectum%  iota_deg = inclination, in degrees [defined as: pi/2 - sgn(L) theta_min]%% this program produces dimenensionless energy, axial angular momentum, % and Certer constant.%%          E = [energy] / mu%         Lz = [axial angular momentum] / (M mu)%          Q = [Carter's constant] / (M mu)^2%% NOTE: this was excerpted from KerrGeodesic.m%% Steve Drasco% 2 July 2008 %% Some of the coments refer to these papers:%% [1] W. Schmidt Class. Quantum Grav. 19 2743 (2002)% [2] S. A. Hughes, Phys. Rev. D 61 084004 (2000)% [3] S. Drasco and S. A. Hughes, astro-ph/0308479 %% WARNING: the notation conventions in these references [1-3] are NOT the % same. For example, z_[2,3] = ( z_[1] )^2.  This code has a mix of the % different conventions.% define "prograde" and theta_iota_rad = pi * iota_deg / 180;if iota_rad < pi/2  prograde = 1;  theta_ = pi/2 - iota_rad;else  prograde = 0;  theta_ = iota_rad - pi/2;end% this routine breaks if the orbit is circularif isequal(e, 0)  error('This program is for non-circular orbits.');end% define z_ as in [1] -- NOT AS IN [2,3]z_ = cos(theta_);% define r1 (rmin) and r2 (rmax)rmin = p / (1.0 + e);rmax = p / (1.0 - e);r1 = rmin;r2 = rmax;% define Schmidt's functions f(r) etc. for r1Delta1 = r1*r1 - 2.0*r1 + a*a;f1 = r1*r1*r1*r1 + a*a*( r1*(r1+2.0) + z_*z_*Delta1 );g1 = 2.0*a*r1;h1 = r1*(r1 - 2.0) + z_*z_*Delta1/(1.0-z_*z_);d1 = (r1*r1 + a*a*z_*z_)*Delta1;% define Schmidt's functions f(r) etc. for r2Delta2 = r2*r2 - 2.0*r2 + a*a;f2 = r2*r2*r2*r2 + a*a*( r2*(r2+2.0) + z_*z_*Delta2 );g2 = 2.0*a*r2;h2 = r2*(r2 - 2.0) + z_*z_*Delta2/(1.0-z_*z_);d2 = (r2*r2 + a*a*z_*z_)*Delta2;% compute determinentskappa =          d1*h2 - d2*h1;epsilon =        d1*g2 - d2*g1;rho =            f1*h2 - f2*h1;eta =            f1*g2 - f2*g1;sigma =          g1*h2 - g2*h1;% compute energy E = kappa*rho + 2.0*epsilon*sigma;E = E +  ((-1)^prograde) *2.0* sqrt(sigma*(sigma*epsilon*epsilon ...    + rho*epsilon*kappa - eta*kappa*kappa) );E = E / ( rho*rho + 4.0*eta*sigma );E = sqrt(E);% compute Lz %% for non-zero a, we can make an equation which is % linear in Lz from Schmidt's Eq. (B.17), by scaling% the two equations and subtracting them so as to % knock out the Lz^2 term to get  %%  Lz = (E*E*rho - kappa) / (2.0*E*sigma).%% This trick doesn't work in the a=0 limit, since % then the "linear" equation doesn't involve Lz.% So, to allow for a=0, we use this ugly block% to get Lz...%if a > 0.001  Lz = (E*E*rho - kappa) / (2.0*E*sigma);else  BB = 2.0*g1*E / h1;  CC = (d1 - f1*E*E) / h1;  if(prograde)    Lz = -0.5*BB + 0.5*sqrt(BB*BB - 4.0*CC);  else    Lz = -0.5*BB - 0.5*sqrt(BB*BB - 4.0*CC);  endend% now compute QQ = z_*z_*(  a*a*(1.0-E*E) + Lz*Lz/(1.0-z_*z_)  );